## 1. 数组名

数组名是指向数组第一个元素的**常量指针**，而不是变量指针，所以不能修改数组名的指向。

数据具有一些和指针完全不同的特征。例如：数组具有确定数量的元素，而指针知识一个标量值。编译器用数组名来记住这些属性。只有数组名在表达式中使用时，编译器才会为它产生一个指针常量。

> 注意这个值是指针常量，而不是指针变量。你不能修改常量的值。你只要稍微回想一下，就会认为这个限制是合理的：指针常量所指向的是内存中数组的起始位置，如果修改这个指针常量，唯一可行的操作就是把整个数组移动到内存的其他位置。但是，在程序完成链接之后，内存中数组的位置是固定的，所以当程序运行时，再想移动数组就为时已晚了。因此，数组名的值是一个指针常量。
>
> [C和指针]: 	"《C和指针》"

## 数组与指针的区别

声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始地址。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何类型值分配内存空间。而且，指针变量并未被初始化为指向任何现有的内存空间，如果它是一个自动变量，它甚至根本不会被初始化。把这两个声明用图的方法来表示，你可以发现它们之间存在显著不同。

![c-array-1.png](images/c-array-1.png)

只有在两种场合下，数组名不用指针常量来表示——就是当数组名作为 sizeof 操作符或单目操作符&的操作数时。sizeof返回整个数组的长度，而不是指向数组的指针的长度。

例子：

```c
int a[10];
int b[10];
int *c;
//...
c = &a[0];
```

表达式&a[0]是一个指向数组第一个元素的指针。但那正是数组名本身的值，所以下面这条赋值语句和上面那条赋值语句所执行的任务是完全一样的：

```c
c = a;
```

## 2. 下标引用

在前面声明的上下文环境中，下面这个表达式是什么意思？

```c
*(b + 3);
```

首先，b的值是一个指向整型的指针，所以3这个值根据整型值的长度进行调整。加法运算的结果是另一个指向整型的指针，它所指向的是数组第一个元素向后移3个整数长度的位置。然后，间接访问操作访问这个新位置，或者取得那里的值（右值），或者把一个新值存储于该处（左值）。

这个过程听上去是不是很熟悉？这是因为他和下标引用的执行过程完全相同。我们现在可以解释第5张所提到的一句话：除了优先级之外，下表引用和间接访问完全相同。例如，下面这两个表达式是等同的：

```c
array[subscript]]
*(array + (subscript))
```





> 详细内容打开**《C和指针（中文版）》**数组部分。